= 文件系统
#label("fs")

== VFS 设计与结构
#label("fs-vfs")

VFS（Virtual File System）是 OS 中具体文件系统之上，内核其他部分之下的一层抽象层。它的存在使内核其他部分能隔离不同底层文件的区别，为 Unix 的著名隐喻 "万物皆文件" 提供了实现上的可能。同时，在此层还能实现许多与具体文件系统无关的优化，比如页缓存与文件共享页管理，路径缓存等，增加了代码复用。MankorOS 自然也采用了 VFS 层的设计。

在 MankorOS 中，VFS 层主要包含如下内容：

- 一层面向内核其他部分的异步文件接口
- 页缓存与映射管理，路径缓存，文件属性管理与同步等通用优化
- 一层面向底层 FS 的抽象接口

通用优化部分使用泛型实现，为底层文件系统的实现者提供了可复用的通用优化代码。底层 FS 若想要使用对应的优化，只需要在返回 root 文件时插入具体优化结构的构造函数即可。对于 tmpfs 与 procfs 等特殊文件系统，它们则可以直接忽略这些优化，直接实现 VFS 顶层的文件接口，减少了不必要的性能开销。

== 非具体文件系统
#label("fs-non-concrete")

在 MankorOS 中，非具体文件系统用于指代所有不需要从磁盘上读取数据的文件系统，包括 procfs, devfs, tmpfs 等。这些文件系统的数据或是从不落盘，或是按需从内核中查询。由于其无需与磁盘交互，因此它们不需要经过常见的为了提高磁盘访问效率而使用的缓存机制，可以直接实现 VFS 顶层的文件接口，从而减少不必要的性能开销。

=== procfs
#label("fs-nc-procfs")

procfs 是一种特殊的文件系统，它不是从磁盘上的文件系统中读取数据，而是从内核中读取数据。MankorOS 实现了部分 linux 中 procfs 的功能，包括：

- `/proc/mounts`: 显示当前挂载的文件系统
- `/proc/<pid>`: 显示对应 pid 进程的信息
- `/proc/self`: 显示当前进程的信息

=== devfs
#label("fs-nc-devfs")

devfs 中的文件代表一些具体的设备，比如终端、硬盘等。MankorOS 的 /dev 内包含：

- `/dev/zero`: 一个无限长的全 0 文件
- `/dev/tty`: 终端设备，能支持 ioctl 中的特定命令

=== tmpfs
#label("fs-nc-tmpfs")

tmpfs 中的一切文件与文件夹都仅仅存活于内存中，在系统重启时被清空。MankorOS 的 `/tmp` 支持创建文件夹、文件、符号链接等普通文件系统的操作，从而支持了 libc 中各类创建临时文件的函数。

== 具体文件系统无关优化
#label("fs-concrete-opt")

在 MankorOS 中，具体文件系统是指那些真实存在于磁盘之上的文件系统。为了提高代码复用效率，减少单模块代码量，在 MankorOS 中，路径缓存与页缓存等通用优化被实现为泛型，其与底层的具体文件系统只通过定义明确的接口交互，从而使得具体文件系统的实现者可以在不需要关心通用优化的情况下，专注于实现具体文件系统的功能。

=== 路径缓存
#label("fs-opt-path-cache")

路径缓存模块在内存中维护真实文件路径树的常用部分，使得用户在路径之间跳转时，得以快速找到对应的文件节点。同时，路径缓存模块也确保了对相同的从文件系统根部开始的路径的重复访问不会导致重复的文件系统操作，也不会找到不同的文件节点，从而保证了文件读写操作的一致性与正确性。

在 Linux 中，"路径缓存" 实则是 "目录项" 的缓存。文件系统中从各个目录读出的 `dentry` 结构体被放置于一张全局哈希表中，使用该目录项名词与文件夹 INode 编号来作为哈希表的键。同一个目录的 DEntry 同时还被侵入式链表相链，以支持目录遍历操作。

在 MankorOS 中，得益于 rust 的高层次描述与丰富的 no-std 标准库，我们选择了直接针对每个目录维护独立的 BTreeMap 来实现路径缓存。这样的实现方式非常简单直观且易于维护，并且在性能上也不会有太大的损失。同时，由于路径缓存保证了每个具体文件系统中的目录最多同时只有一个 VFS 中的文件对象与其对应，我们可以确保所有对该目录的修改操作都会经过同一个对象，从而确保我们的缓存系统能检测到每一次更改。我们在每一个目录中维护了一个当前缓存是否完全的 flag, 借此便可以 (在缓存完全的情况下) 高效地判定一个文件是否存在，而无需在缓存查找失败时再次向底层文件系统发出查询。

=== 页缓存与文件共享页管理
#label("fs-opt-page-cache")

页缓存指的是将整个文件按页大小 (`PAGE_SIZE`) 切分维护，从而为上层的文件映射 (mmap private/shared) 提供高效支持的机制。页缓存可以确保每一张共享映射的页在内存中都是同一张，从而保证共享页的唯一性。同时，将文件按页维护切分维护也能方便地进行整页的 IO 读写操作，从而提高 IO 效率。页缓存对于异步内核而言，在实现文件异步读写时也具有重要意义：它可以将 "读取文件" 的操作分离为 "向底层文件系统发出请求，等待其将数据写到页中" 与 "从缓存页中复制数据到外界缓冲区" 两次操作，前者为异步操作，后者则可实现为同步操作，这极大地便利了 poll/select 等多路转发机制的实现，在 poll 具体文件时提升 IO 吞吐量 (只有数据立即在内存之中的文件才会返回 poll ready, 需要进行耗时的磁盘访问的文件则不会 ready), 并且可以在等待磁盘 IO 时切换当前 hart 到其他任务上。

== 异步 FAT32 文件系统
#label("fs-fat32")

为了更好地与 MankorOS 的异步系统集成，在决赛第一阶段我们抛弃了初赛中使用的第三方同步 fat32 文件系统，代之以自己实现的异步 fat32 系统。它依赖于我们底层的异步块设备接口，能直接与我们的异步 SD 卡驱动对接，从而实现真正的异步文件 IO.

=== 异步块设备接口
#label("fs-fat32-block-device")

```rust 
pub trait AsyncBlockDevice: Device + Debug {
    fn num_blocks(&self) -> u64;
    fn block_size(&self) -> usize;

    fn read_block(&self, block_id: u64, buf: &mut [u8]) -> ADevResult;
    fn write_block(&self, block_id: u64, buf: &[u8]) -> ADevResult;
    fn flush(&self) -> ADevResult;
}
```

=== 文件系统信息与 fat 表
#label("fs-fat32-info")

=== 文件与文件元信息的维护
#label("fs-fat32-file-meta")

=== 文件夹
#label("fs-fat32-dir")

=== 分区支持
#label("fs-fat32-partition")

MankorOS 还支持 MBR 格式的分区表，如果块设备上存在有 MBR 分区表，MankorOS 可以解析并挂载上面的多个文件系统。

区域赛中，MankorOS 自动从 virtio blk 设备上识别 FAT32 文件系统，并能够自动执行上面的测试程序。